<!DOCTYPE html>
<html>
<head>
  <title>Jellyfish Perf Test</title>
  <style>
    * { margin: 0; padding: 0; }
    body { background: #000d1a; overflow: hidden; }
    canvas { display: block; }
    #status { position: fixed; top: 10px; left: 10px; color: #0ff; font-family: monospace; z-index: 100; }
  </style>
</head>
<body>
  <div id="status">Initializing...</div>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js"
    }
  }
  </script>
  <script type="module">
    import * as THREE from 'three';

    const WIDTH = 1920;
    const HEIGHT = 1080;
    const TEST_DURATION = 10000;
    const WARMUP_DURATION = 2000;

    // FPS tracking
    window.__fpsData = {
      samples: [],
      lastTime: 0,
      frameCount: 0,
      measuring: false,
      done: false,
      result: null,
    };

    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(55, WIDTH / HEIGHT, 0.1, 1000);
    camera.position.set(0, 0, 7);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(WIDTH, HEIGHT);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    document.body.appendChild(renderer.domElement);

    // Lighting
    scene.add(new THREE.AmbientLight(0x001828, 0.06));
    const mainLight = new THREE.PointLight(0x00ffaa, 1.5, 15);
    mainLight.position.set(0, 0.3, -0.5);
    scene.add(mainLight);

    // Jellyfish shader material (simplified from JellyfishCore.tsx)
    const jellyfishMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 },
        uDecay: { value: 0 },
      },
      vertexShader: `
        uniform float uTime;
        uniform float uDecay;
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying float vDisplacement;

        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

        float snoise(vec3 v) {
          const vec2 C = vec2(1.0/6.0, 1.0/3.0);
          const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
          vec3 i = floor(v + dot(v, C.yyy));
          vec3 x0 = v - i + dot(i, C.xxx);
          vec3 g = step(x0.yzx, x0.xyz);
          vec3 l = 1.0 - g;
          vec3 i1 = min(g.xyz, l.zxy);
          vec3 i2 = max(g.xyz, l.zxy);
          vec3 x1 = x0 - i1 + C.xxx;
          vec3 x2 = x0 - i2 + C.yyy;
          vec3 x3 = x0 - D.yyy;
          i = mod289(i);
          vec4 p = permute(permute(permute(
            i.z + vec4(0.0, i1.z, i2.z, 1.0))
            + i.y + vec4(0.0, i1.y, i2.y, 1.0))
            + i.x + vec4(0.0, i1.x, i2.x, 1.0));
          float n_ = 0.142857142857;
          vec3 ns = n_ * D.wyz - D.xzx;
          vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
          vec4 x_ = floor(j * ns.z);
          vec4 y_ = floor(j - 7.0 * x_);
          vec4 x = x_ *ns.x + ns.yyyy;
          vec4 y = y_ *ns.x + ns.yyyy;
          vec4 h = 1.0 - abs(x) - abs(y);
          vec4 b0 = vec4(x.xy, y.xy);
          vec4 b1 = vec4(x.zw, y.zw);
          vec4 s0 = floor(b0)*2.0 + 1.0;
          vec4 s1 = floor(b1)*2.0 + 1.0;
          vec4 sh = -step(h, vec4(0.0));
          vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
          vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
          vec3 p0 = vec3(a0.xy, h.x);
          vec3 p1 = vec3(a0.zw, h.y);
          vec3 p2 = vec3(a1.xy, h.z);
          vec3 p3 = vec3(a1.zw, h.w);
          vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
          p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
          vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
          m = m * m;
          return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
        }

        void main() {
          vNormal = normal;
          vPosition = position;

          float verticalPos = position.y;
          float bellFactor = smoothstep(-1.0, 0.5, verticalPos);
          float contraction = uDecay * 0.3 * bellFactor;

          vec3 noisePos = position * 2.0;
          float undulation = snoise(noisePos + uTime * 0.3) * 0.12;
          undulation += snoise(noisePos * 1.5 + uTime * 0.5) * 0.06;

          float ripple = sin(verticalPos * 8.0 - uTime * 3.0) * 0.04 * uDecay;
          float breathe = sin(uTime * 1.5) * 0.06;
          float displacement = -contraction + undulation + ripple + breathe;
          vDisplacement = displacement;

          vec3 newPosition = position + normal * displacement;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
        }
      `,
      fragmentShader: `
        uniform float uTime;
        uniform float uDecay;
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying float vDisplacement;

        void main() {
          float fresnel = pow(1.0 - abs(dot(normalize(cameraPosition - vPosition), vNormal)), 3.0);
          float verticalGrad = smoothstep(-0.5, 0.5, vPosition.y);

          vec3 coreColor = vec3(0.0, 0.5, 0.4);
          vec3 rimColor = vec3(0.0, 0.4, 0.8);
          vec3 pulseColor = vec3(0.1, 0.9, 0.7);

          vec3 color = mix(coreColor, rimColor, fresnel * 0.6);
          float pulseIntensity = uDecay * 0.8;
          color = mix(color, pulseColor, pulseIntensity * verticalGrad);
          color += rimColor * fresnel * (0.4 + uDecay * 0.6);

          float alpha = 0.35 + fresnel * 0.45 + uDecay * 0.15;
          gl_FragColor = vec4(color, alpha);
        }
      `,
      transparent: true,
      side: THREE.DoubleSide,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
    });

    // Create jellyfish mesh
    const jellyfish = new THREE.Mesh(
      new THREE.SphereGeometry(1, 32, 32, Math.PI),
      jellyfishMaterial
    );
    jellyfish.rotation.x = -Math.PI / 2;
    jellyfish.scale.setScalar(1.3);
    scene.add(jellyfish);

    // Particles (from OceanEnvironment)
    const particleCount = 600;
    const particleGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    for (let i = 0; i < particleCount; i++) {
      positions[i * 3] = (Math.random() - 0.5) * 16;
      positions[i * 3 + 1] = Math.random() * 6 - 2;
      positions[i * 3 + 2] = Math.random() * -60;
    }
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const particleMaterial = new THREE.PointsMaterial({
      color: 0x66ddff,
      size: 0.05,
      transparent: true,
      opacity: 0.6,
      blending: THREE.AdditiveBlending,
    });
    const particles = new THREE.Points(particleGeometry, particleMaterial);
    scene.add(particles);

    // Tendrils (simplified)
    const tendrilCount = 14;
    const tendrils = [];
    for (let i = 0; i < tendrilCount; i++) {
      const angle = (i / tendrilCount) * Math.PI * 2;
      const radius = 0.4;
      const points = [];
      for (let j = 0; j <= 20; j++) {
        const t = j / 20;
        points.push(new THREE.Vector3(
          Math.cos(angle) * radius + Math.sin(t * 3) * t * 0.3,
          -t * 2.5,
          Math.sin(angle) * radius + Math.cos(t * 2) * t * 0.2
        ));
      }
      const curve = new THREE.CatmullRomCurve3(points);
      const tubeGeom = new THREE.TubeGeometry(curve, 16, 0.03, 6, false);
      const tendrilMesh = new THREE.Mesh(tubeGeom, new THREE.MeshBasicMaterial({
        color: 0x00ff88,
        transparent: true,
        opacity: 0.5,
        blending: THREE.AdditiveBlending,
      }));
      tendrilMesh.position.set(0, 0, 0.3);
      tendrilMesh.rotation.x = -Math.PI / 2;
      scene.add(tendrilMesh);
      tendrils.push({ mesh: tendrilMesh, angle, basePoints: points });
    }

    // Animation
    const clock = new THREE.Clock();
    let startTime = null;
    let warmupComplete = false;
    let measurementStart = null;

    function animate() {
      if (window.__fpsData.done) return;

      requestAnimationFrame(animate);

      const elapsed = clock.getElapsedTime();
      const now = performance.now();

      // Simulated audio decay (pulsing)
      const decay = (Math.sin(elapsed * 2) * 0.5 + 0.5) * 0.7;

      // Update jellyfish
      jellyfishMaterial.uniforms.uTime.value = elapsed;
      jellyfishMaterial.uniforms.uDecay.value = decay;
      jellyfish.scale.setScalar(1.3 * (1 + decay * 0.1));

      // Camera orbit
      const camAngle = elapsed * 0.2;
      camera.position.x = Math.sin(camAngle) * 5;
      camera.position.z = Math.cos(camAngle) * 5;
      camera.position.y = Math.sin(elapsed * 0.3) * 2;
      camera.lookAt(0, 0, 0);

      // Render
      renderer.render(scene, camera);

      // FPS tracking
      if (startTime === null) {
        startTime = now;
        document.getElementById('status').textContent = 'Warming up...';
      }

      const timeSinceStart = now - startTime;

      if (!warmupComplete && timeSinceStart >= WARMUP_DURATION) {
        warmupComplete = true;
        measurementStart = now;
        window.__fpsData.measuring = true;
        window.__fpsData.lastTime = now;
        window.__fpsData.frameCount = 0;
        document.getElementById('status').textContent = 'Measuring FPS...';
      }

      if (warmupComplete && window.__fpsData.measuring) {
        window.__fpsData.frameCount++;
        const measureElapsed = now - window.__fpsData.lastTime;
        if (measureElapsed >= 1000) {
          const fps = (window.__fpsData.frameCount * 1000) / measureElapsed;
          window.__fpsData.samples.push(fps);
          window.__fpsData.frameCount = 0;
          window.__fpsData.lastTime = now;
        }

        // Check if measurement complete
        if (now - measurementStart >= TEST_DURATION) {
          window.__fpsData.measuring = false;
          window.__fpsData.done = true;

          const samples = window.__fpsData.samples;
          if (samples.length > 0) {
            const sum = samples.reduce((a, b) => a + b, 0);
            const avg = sum / samples.length;
            window.__fpsData.result = {
              averageFps: Math.round(avg * 100) / 100,
              minFps: Math.round(Math.min(...samples) * 100) / 100,
              maxFps: Math.round(Math.max(...samples) * 100) / 100,
              samples: samples.map(s => Math.round(s * 100) / 100),
              sampleCount: samples.length,
            };
          } else {
            window.__fpsData.result = { error: "No samples collected" };
          }
          document.getElementById('status').textContent = 'Done: ' + JSON.stringify(window.__fpsData.result);
        }
      }
    }

    animate();
  </script>
</body>
</html>
