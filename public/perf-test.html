<!DOCTYPE html>
<html>
<head>
  <title>Jellyfish Perf Test</title>
  <style>
    * { margin: 0; padding: 0; }
    body { background: #000d1a; overflow: hidden; }
    canvas { display: block; }
    #status { position: fixed; top: 10px; left: 10px; color: #0ff; font-family: monospace; z-index: 100; }
  </style>
</head>
<body>
  <div id="status">Initializing...</div>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js"
    }
  }
  </script>
  <script type="module">
    import * as THREE from 'three';

    const WIDTH = 1920;
    const HEIGHT = 1080;
    const TEST_DURATION = 10000;
    const WARMUP_DURATION = 2000;

    // FPS tracking
    window.__fpsData = {
      samples: [],
      lastTime: 0,
      frameCount: 0,
      measuring: false,
      done: false,
      result: null,
    };

    function seededRandom(seed) {
      const x = Math.sin(seed * 12.9898 + 78.233) * 43758.5453;
      return x - Math.floor(x);
    }

    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(55, WIDTH / HEIGHT, 0.1, 1000);
    camera.position.set(0, 0, 7);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(WIDTH, HEIGHT);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    document.body.appendChild(renderer.domElement);

    // Lighting
    scene.add(new THREE.AmbientLight(0x001828, 0.06));
    const mainLight = new THREE.PointLight(0x00ffaa, 1.5, 15);
    mainLight.position.set(0, 0.3, -0.5);
    scene.add(mainLight);

    // Jellyfish shader material
    const jellyfishMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 },
        uDecay: { value: 0 },
      },
      vertexShader: `
        uniform float uTime;
        uniform float uDecay;
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying float vDisplacement;

        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

        float snoise(vec3 v) {
          const vec2 C = vec2(1.0/6.0, 1.0/3.0);
          const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
          vec3 i = floor(v + dot(v, C.yyy));
          vec3 x0 = v - i + dot(i, C.xxx);
          vec3 g = step(x0.yzx, x0.xyz);
          vec3 l = 1.0 - g;
          vec3 i1 = min(g.xyz, l.zxy);
          vec3 i2 = max(g.xyz, l.zxy);
          vec3 x1 = x0 - i1 + C.xxx;
          vec3 x2 = x0 - i2 + C.yyy;
          vec3 x3 = x0 - D.yyy;
          i = mod289(i);
          vec4 p = permute(permute(permute(
            i.z + vec4(0.0, i1.z, i2.z, 1.0))
            + i.y + vec4(0.0, i1.y, i2.y, 1.0))
            + i.x + vec4(0.0, i1.x, i2.x, 1.0));
          float n_ = 0.142857142857;
          vec3 ns = n_ * D.wyz - D.xzx;
          vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
          vec4 x_ = floor(j * ns.z);
          vec4 y_ = floor(j - 7.0 * x_);
          vec4 x = x_ *ns.x + ns.yyyy;
          vec4 y = y_ *ns.x + ns.yyyy;
          vec4 h = 1.0 - abs(x) - abs(y);
          vec4 b0 = vec4(x.xy, y.xy);
          vec4 b1 = vec4(x.zw, y.zw);
          vec4 s0 = floor(b0)*2.0 + 1.0;
          vec4 s1 = floor(b1)*2.0 + 1.0;
          vec4 sh = -step(h, vec4(0.0));
          vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
          vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
          vec3 p0 = vec3(a0.xy, h.x);
          vec3 p1 = vec3(a0.zw, h.y);
          vec3 p2 = vec3(a1.xy, h.z);
          vec3 p3 = vec3(a1.zw, h.w);
          vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
          p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
          vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
          m = m * m;
          return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
        }

        void main() {
          vNormal = normal;
          vPosition = position;

          float verticalPos = position.y;
          float bellFactor = smoothstep(-1.0, 0.5, verticalPos);
          float contraction = uDecay * 0.3 * bellFactor;

          vec3 noisePos = position * 2.0;
          float undulation = snoise(noisePos + uTime * 0.3) * 0.12;
          undulation += snoise(noisePos * 1.5 + uTime * 0.5) * 0.06;

          float ripple = sin(verticalPos * 8.0 - uTime * 3.0) * 0.04 * uDecay;
          float breathe = sin(uTime * 1.5) * 0.06;
          float displacement = -contraction + undulation + ripple + breathe;
          vDisplacement = displacement;

          vec3 newPosition = position + normal * displacement;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
        }
      `,
      fragmentShader: `
        uniform float uTime;
        uniform float uDecay;
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying float vDisplacement;

        void main() {
          float fresnel = pow(1.0 - abs(dot(normalize(cameraPosition - vPosition), vNormal)), 3.0);
          float verticalGrad = smoothstep(-0.5, 0.5, vPosition.y);

          vec3 coreColor = vec3(0.0, 0.5, 0.4);
          vec3 rimColor = vec3(0.0, 0.4, 0.8);
          vec3 pulseColor = vec3(0.1, 0.9, 0.7);

          vec3 color = mix(coreColor, rimColor, fresnel * 0.6);
          float pulseIntensity = uDecay * 0.8;
          color = mix(color, pulseColor, pulseIntensity * verticalGrad);
          color += rimColor * fresnel * (0.4 + uDecay * 0.6);

          float alpha = 0.35 + fresnel * 0.45 + uDecay * 0.15;
          gl_FragColor = vec4(color, alpha);
        }
      `,
      transparent: true,
      side: THREE.DoubleSide,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
    });

    // Create jellyfish mesh
    const jellyfish = new THREE.Mesh(
      new THREE.SphereGeometry(1, 32, 32, Math.PI),
      jellyfishMaterial
    );
    jellyfish.rotation.x = -Math.PI / 2;
    jellyfish.scale.setScalar(1.3);
    scene.add(jellyfish);

    // Particles (600 like actual scene)
    const particleCount = 600;
    const particleGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    for (let i = 0; i < particleCount; i++) {
      positions[i * 3] = (Math.random() - 0.5) * 16;
      positions[i * 3 + 1] = Math.random() * 6 - 2;
      positions[i * 3 + 2] = Math.random() * -60;
    }
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const particleMaterial = new THREE.PointsMaterial({
      color: 0x66ddff,
      size: 0.05,
      transparent: true,
      opacity: 0.6,
      blending: THREE.AdditiveBlending,
    });
    const particles = new THREE.Points(particleGeometry, particleMaterial);
    scene.add(particles);

    // ============================================================
    // TENDRILS - matches Tendrils.tsx behavior exactly
    // 12 tendrils, geometry rebuilt when quantizedPhase changes (~30/sec)
    // ============================================================
    const tendrilCount = 12;
    const tendrilConfigs = [];
    for (let i = 0; i < tendrilCount; i++) {
      const angle = (i / tendrilCount) * Math.PI * 2;
      tendrilConfigs.push({
        baseAngle: angle,
        radiusOffset: 0.35 + seededRandom(i * 7) * 0.25,
        length: 2.5 + seededRandom(i * 11) * 1.5,
        phaseOffset: seededRandom(i * 13) * Math.PI * 2,
        thickness: 0.035 + seededRandom(i * 17) * 0.03,
        segments: 32,
      });
    }

    const tendrilMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ff88,
      transparent: true,
      opacity: 0.5,
      blending: THREE.AdditiveBlending,
      side: THREE.DoubleSide,
    });

    const tendrilGroup = new THREE.Group();
    tendrilGroup.position.set(0, 0, 0.3);
    tendrilGroup.rotation.x = -Math.PI / 2;
    scene.add(tendrilGroup);

    let tendrilMeshes = [];
    let lastQuantizedPhase = -999;

    function rebuildTendrils(quantizedPhase) {
      // Dispose old geometries
      tendrilMeshes.forEach(m => {
        tendrilGroup.remove(m);
        m.geometry.dispose();
      });
      tendrilMeshes = [];

      // Rebuild all 12 tendrils (matching Tendrils.tsx)
      for (let i = 0; i < tendrilCount; i++) {
        const tendril = tendrilConfigs[i];
        const attachX = Math.cos(tendril.baseAngle) * tendril.radiusOffset;
        const attachZ = Math.sin(tendril.baseAngle) * tendril.radiusOffset;

        const points = [];
        for (let j = 0; j <= tendril.segments; j++) {
          const t = j / tendril.segments;
          const y = -t * tendril.length;

          const swayAmount = Math.pow(t, 1.3) * 0.8;
          const swayPhase = quantizedPhase + tendril.phaseOffset;
          const swayX = Math.sin(swayPhase * 0.8 + t * 2.5) * swayAmount;
          const swayZ = Math.cos(swayPhase * 0.6 + t * 2.0) * swayAmount * 0.6;

          const secondaryX = Math.sin(swayPhase * 0.3 + t * 1.2 + i) * swayAmount * 0.25;
          const secondaryZ = Math.cos(swayPhase * 0.25 + t * 1.0 + i * 0.5) * swayAmount * 0.2;

          points.push(new THREE.Vector3(
            attachX + swayX + secondaryX,
            y,
            attachZ + swayZ + secondaryZ
          ));
        }

        const curve = new THREE.CatmullRomCurve3(points);
        const tubeGeom = new THREE.TubeGeometry(curve, 24, tendril.thickness * 1.5, 8, false);
        const mesh = new THREE.Mesh(tubeGeom, tendrilMaterial);
        tendrilGroup.add(mesh);
        tendrilMeshes.push(mesh);
      }
    }

    // ============================================================
    // SEAWEED - matches OceanEnvironment.tsx behavior exactly
    // 50 seaweed strands, geometry rebuilt when quantizedTime changes (~20/sec)
    // ============================================================
    const seaweedCount = 50;
    const seaweedLoopLength = 180;
    const seaweedConfigs = [];
    for (let i = 0; i < seaweedCount; i++) {
      seaweedConfigs.push({
        x: (seededRandom(i * 37) - 0.5) * 40,
        zOffset: (i / seaweedCount) * seaweedLoopLength + seededRandom(i * 41) * 8,
        height: 2.0 + seededRandom(i * 43) * 2.5,
        phase: seededRandom(i * 47) * Math.PI * 2,
        thickness: 0.08 + seededRandom(i * 53) * 0.1,
      });
    }

    const seaweedMaterial = new THREE.MeshBasicMaterial({
      color: 0x0a5030,
      transparent: true,
      opacity: 0.6,
      side: THREE.DoubleSide,
    });

    let seaweedMeshes = [];
    let lastQuantizedTime = -999;

    function rebuildSeaweed(quantizedTime, travel) {
      // Dispose old geometries
      seaweedMeshes.forEach(m => {
        scene.remove(m);
        m.geometry.dispose();
      });
      seaweedMeshes = [];

      // Rebuild all 50 seaweed strands (matching OceanEnvironment.tsx)
      for (let i = 0; i < seaweedCount; i++) {
        const weed = seaweedConfigs[i];
        const segments = 12;
        const points = [];

        for (let j = 0; j <= segments; j++) {
          const t = j / segments;
          const swayPhase = quantizedTime * 1.5 + weed.phase + t * 2;
          const sway = Math.sin(swayPhase) * 0.3 * t * t;
          const secondarySway = Math.sin(swayPhase * 1.7 + 1) * 0.15 * t;
          points.push(new THREE.Vector3(
            sway + secondarySway,
            t * weed.height,
            Math.sin(swayPhase * 0.8) * 0.1 * t
          ));
        }

        const curve = new THREE.CatmullRomCurve3(points);
        const tubeGeom = new THREE.TubeGeometry(curve, 8, weed.thickness, 6, false);
        const mesh = new THREE.Mesh(tubeGeom, seaweedMaterial);

        const z = ((weed.zOffset + travel) % seaweedLoopLength) - 80;
        mesh.position.set(weed.x, -5, z);

        scene.add(mesh);
        seaweedMeshes.push(mesh);
      }
    }

    // Animation
    const clock = new THREE.Clock();
    let startTime = null;
    let warmupComplete = false;
    let measurementStart = null;

    // Phase accumulation (matching Tendrils.tsx)
    let phase = 0;
    let lastTime = 0;
    const baseSpeed = 1.0;
    const boostSpeed = 3.0;

    // Travel accumulation (matching OceanEnvironment.tsx)
    let travel = 0;
    const travelBaseSpeed = 4.0;
    const travelBoostSpeed = 35.0;

    function animate() {
      if (window.__fpsData.done) return;

      const now = performance.now();
      const elapsed = clock.getElapsedTime();

      // Simulated audio decay (pulsing)
      const decay = (Math.sin(elapsed * 2) * 0.5 + 0.5) * 0.7;

      // Update phase (matching Tendrils.tsx accumulation)
      const deltaTime = Math.min(elapsed - lastTime, 0.1);
      if (deltaTime > 0) {
        phase += (baseSpeed + decay * boostSpeed) * deltaTime;
        travel += (travelBaseSpeed + decay * travelBoostSpeed) * deltaTime;
      }
      lastTime = elapsed;

      // Quantize phase at 30/sec (matching Tendrils.tsx)
      const quantizedPhase = Math.floor(phase * 30) / 30;
      if (quantizedPhase !== lastQuantizedPhase) {
        rebuildTendrils(quantizedPhase);
        lastQuantizedPhase = quantizedPhase;
      }

      // Quantize time at 20/sec (matching OceanEnvironment.tsx)
      const quantizedTime = Math.floor(elapsed * 20) / 20;
      if (quantizedTime !== lastQuantizedTime) {
        rebuildSeaweed(quantizedTime, travel);
        lastQuantizedTime = quantizedTime;
      }

      // Update seaweed positions (they move with travel even between rebuilds)
      seaweedMeshes.forEach((mesh, i) => {
        const weed = seaweedConfigs[i];
        const z = ((weed.zOffset + travel) % seaweedLoopLength) - 80;
        mesh.position.z = z;
      });

      // Update jellyfish
      jellyfishMaterial.uniforms.uTime.value = elapsed;
      jellyfishMaterial.uniforms.uDecay.value = decay;
      jellyfish.scale.setScalar(1.3 * (1 + decay * 0.1));

      // Camera orbit
      const camAngle = elapsed * 0.2;
      camera.position.x = Math.sin(camAngle) * 5;
      camera.position.z = Math.cos(camAngle) * 5;
      camera.position.y = Math.sin(elapsed * 0.3) * 2;
      camera.lookAt(0, 0, 0);

      // Render
      renderer.render(scene, camera);

      // FPS tracking
      if (startTime === null) {
        startTime = now;
        document.getElementById('status').textContent = 'Warming up...';
      }

      const timeSinceStart = now - startTime;

      if (!warmupComplete && timeSinceStart >= WARMUP_DURATION) {
        warmupComplete = true;
        measurementStart = now;
        window.__fpsData.measuring = true;
        window.__fpsData.lastTime = now;
        window.__fpsData.frameCount = 0;
        document.getElementById('status').textContent = 'Measuring FPS...';
      }

      if (warmupComplete && window.__fpsData.measuring) {
        window.__fpsData.frameCount++;
        const measureElapsed = now - window.__fpsData.lastTime;
        if (measureElapsed >= 1000) {
          const fps = (window.__fpsData.frameCount * 1000) / measureElapsed;
          window.__fpsData.samples.push(fps);
          window.__fpsData.frameCount = 0;
          window.__fpsData.lastTime = now;
        }

        // Check if measurement complete
        if (now - measurementStart >= TEST_DURATION) {
          window.__fpsData.measuring = false;
          window.__fpsData.done = true;

          const samples = window.__fpsData.samples;
          if (samples.length > 0) {
            const sum = samples.reduce((a, b) => a + b, 0);
            const avg = sum / samples.length;
            window.__fpsData.result = {
              averageFps: Math.round(avg * 100) / 100,
              minFps: Math.round(Math.min(...samples) * 100) / 100,
              maxFps: Math.round(Math.max(...samples) * 100) / 100,
              samples: samples.map(s => Math.round(s * 100) / 100),
              sampleCount: samples.length,
            };
          } else {
            window.__fpsData.result = { error: "No samples collected" };
          }
          document.getElementById('status').textContent = 'Done: ' + JSON.stringify(window.__fpsData.result);
          return;
        }
      }

      // Use setTimeout(0) to measure uncapped FPS
      setTimeout(animate, 0);
    }

    animate();
  </script>
</body>
</html>
