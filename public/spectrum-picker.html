<!DOCTYPE html>
<html>
<head>
  <title>Spectrum Picker</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: #0a0a0f;
      color: #fff;
      font-family: monospace;
      padding: 20px;
    }
    h1 { margin-bottom: 10px; color: #0ff; }
    .controls { margin-bottom: 15px; display: flex; gap: 15px; align-items: center; }
    button {
      background: #0ff;
      color: #000;
      border: none;
      padding: 8px 16px;
      cursor: pointer;
      font-family: monospace;
      font-weight: bold;
    }
    button:hover { background: #0aa; }
    #fileInput { color: #fff; }

    .spectrum-container {
      position: relative;
      width: 100%;
      height: 300px;
      background: #111;
      border: 1px solid #333;
      margin-bottom: 20px;
    }
    #spectrum { width: 100%; height: 100%; }

    .range-box {
      position: absolute;
      border: 2px solid #0ff;
      background: rgba(0, 255, 255, 0.1);
      cursor: move;
      min-width: 20px;
      min-height: 20px;
    }
    .range-box .handle {
      position: absolute;
      width: 10px;
      height: 10px;
      background: #0ff;
      border-radius: 50%;
    }
    .range-box .handle.tl { top: -5px; left: -5px; cursor: nwse-resize; }
    .range-box .handle.tr { top: -5px; right: -5px; cursor: nesw-resize; }
    .range-box .handle.bl { bottom: -5px; left: -5px; cursor: nesw-resize; }
    .range-box .handle.br { bottom: -5px; right: -5px; cursor: nwse-resize; }

    .fill-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 255, 255, 0.4);
      pointer-events: none;
    }

    .output {
      background: #1a1a2e;
      padding: 15px;
      border: 1px solid #333;
      margin-bottom: 15px;
    }
    .output h3 { color: #0ff; margin-bottom: 10px; }
    .output pre {
      background: #000;
      padding: 10px;
      overflow-x: auto;
      font-size: 12px;
      line-height: 1.4;
    }
    .output .value { color: #0f0; font-size: 24px; margin: 10px 0; }

    .meters {
      display: flex;
      gap: 20px;
      margin-bottom: 15px;
    }
    .meter {
      flex: 1;
      background: #1a1a2e;
      padding: 10px;
      border: 1px solid #333;
    }
    .meter-label { font-size: 11px; color: #888; margin-bottom: 5px; }
    .meter-bar {
      height: 20px;
      background: #222;
      position: relative;
    }
    .meter-fill {
      height: 100%;
      background: linear-gradient(90deg, #0a0, #0f0);
      transition: width 0.05s;
    }
    .meter-value {
      position: absolute;
      right: 5px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 11px;
    }

    .instructions {
      background: #1a1a2e;
      padding: 15px;
      border: 1px solid #333;
      font-size: 12px;
      line-height: 1.6;
    }
    .instructions h3 { color: #0ff; margin-bottom: 10px; }
    .instructions ul { margin-left: 20px; }
  </style>
</head>
<body>
  <h1>Spectrum Picker</h1>

  <div class="controls">
    <input type="file" id="fileInput" accept="audio/*">
    <button id="playBtn">Play</button>
    <button id="stopBtn">Stop</button>
    <span id="status">Load an audio file</span>
  </div>

  <div class="spectrum-container" id="container">
    <canvas id="spectrum"></canvas>
    <div class="range-box" id="rangeBox">
      <div class="handle tl"></div>
      <div class="handle tr"></div>
      <div class="handle bl"></div>
      <div class="handle br"></div>
      <div class="fill-bar" id="fillBar"></div>
    </div>
  </div>

  <div class="meters">
    <div class="meter">
      <div class="meter-label">FILL PERCENTAGE (what you want)</div>
      <div class="meter-bar">
        <div class="meter-fill" id="fillMeter"></div>
        <span class="meter-value" id="fillValue">0%</span>
      </div>
    </div>
    <div class="meter">
      <div class="meter-label">RAW PEAK (before threshold)</div>
      <div class="meter-bar">
        <div class="meter-fill" id="peakMeter" style="background: linear-gradient(90deg, #a00, #f00);"></div>
        <span class="meter-value" id="peakValue">0%</span>
      </div>
    </div>
  </div>

  <div class="output">
    <h3>Copy this config:</h3>
    <pre id="configOutput">// Load audio and adjust the range box</pre>
    <div class="value">Fill: <span id="fillDisplay">0%</span></div>
  </div>

  <div class="instructions">
    <h3>How to use:</h3>
    <ul>
      <li>Load your audio file (the same one used in Remotion)</li>
      <li>Click Play</li>
      <li>Drag the cyan box horizontally to select frequency range (left = low Hz, right = high Hz)</li>
      <li>Drag vertically to set threshold (lower = more sensitive)</li>
      <li>Resize using corner handles</li>
      <li>Watch the FILL meter - it should hit ~100% on kick hits and ~0% between</li>
      <li>Copy the config and give it to me</li>
    </ul>
  </div>

<script>
// Audio context and nodes
let audioCtx, analyser, source, audioBuffer;
let isPlaying = false;
let startTime = 0;
let animationId;

// Canvas
const canvas = document.getElementById('spectrum');
const ctx = canvas.getContext('2d');
const container = document.getElementById('container');

// Range box state (normalized 0-1)
let boxNorm = { x: 0.05, y: 0.3, w: 0.15, h: 0.4 };

// Elements
const rangeBox = document.getElementById('rangeBox');
const fillBar = document.getElementById('fillBar');
const fillMeter = document.getElementById('fillMeter');
const fillValue = document.getElementById('fillValue');
const peakMeter = document.getElementById('peakMeter');
const peakValue = document.getElementById('peakValue');
const fillDisplay = document.getElementById('fillDisplay');
const configOutput = document.getElementById('configOutput');
const status = document.getElementById('status');

// File loading
document.getElementById('fileInput').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;

  status.textContent = 'Loading...';

  if (!audioCtx) {
    audioCtx = new AudioContext();
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 4096;
    analyser.smoothingTimeConstant = 0;
  }

  const arrayBuffer = await file.arrayBuffer();
  audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
  status.textContent = `Loaded: ${file.name} (${audioBuffer.duration.toFixed(1)}s)`;
});

// Play/Stop
document.getElementById('playBtn').addEventListener('click', () => {
  if (!audioBuffer || isPlaying) return;

  if (audioCtx.state === 'suspended') audioCtx.resume();

  source = audioCtx.createBufferSource();
  source.buffer = audioBuffer;
  source.connect(analyser);
  analyser.connect(audioCtx.destination);
  source.start();
  isPlaying = true;
  startTime = audioCtx.currentTime;
  status.textContent = 'Playing...';

  source.onended = () => {
    isPlaying = false;
    status.textContent = 'Stopped';
  };
});

document.getElementById('stopBtn').addEventListener('click', () => {
  if (source && isPlaying) {
    source.stop();
    isPlaying = false;
    status.textContent = 'Stopped';
  }
});

// Resize canvas
function resizeCanvas() {
  const rect = container.getBoundingClientRect();
  canvas.width = rect.width;
  canvas.height = rect.height;
  updateBoxPosition();
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Update box DOM position from normalized state
function updateBoxPosition() {
  const rect = container.getBoundingClientRect();
  rangeBox.style.left = (boxNorm.x * rect.width) + 'px';
  rangeBox.style.top = (boxNorm.y * rect.height) + 'px';
  rangeBox.style.width = (boxNorm.w * rect.width) + 'px';
  rangeBox.style.height = (boxNorm.h * rect.height) + 'px';
  updateConfig();
}

// Convert box position to frequency/threshold values
function getConfig() {
  const sampleRate = audioBuffer?.sampleRate || 44100;
  const fftSize = 4096;
  const binCount = fftSize / 2;
  const maxFreq = sampleRate / 2; // Nyquist

  // X position maps to frequency (log scale for better low-freq resolution)
  const minLog = Math.log10(20);
  const maxLog = Math.log10(maxFreq);
  const logRange = maxLog - minLog;

  const minHz = Math.pow(10, minLog + boxNorm.x * logRange);
  const maxHz = Math.pow(10, minLog + (boxNorm.x + boxNorm.w) * logRange);

  // Y position maps to threshold (inverted: top = high threshold)
  const floor = 1 - (boxNorm.y + boxNorm.h); // Bottom of box
  const ceiling = 1 - boxNorm.y; // Top of box

  return {
    minHz: Math.round(minHz),
    maxHz: Math.round(maxHz),
    floor: Math.round(floor * 100) / 100,
    ceiling: Math.round(ceiling * 100) / 100,
  };
}

function updateConfig() {
  const cfg = getConfig();
  configOutput.textContent = `{
  minHz: ${cfg.minHz},
  maxHz: ${cfg.maxHz},
  floor: ${cfg.floor},
  ceiling: ${cfg.ceiling},
}`;
}

// Range box dragging
let dragState = null;

rangeBox.addEventListener('mousedown', (e) => {
  e.preventDefault();
  const rect = container.getBoundingClientRect();
  const boxRect = rangeBox.getBoundingClientRect();

  const isHandle = e.target.classList.contains('handle');
  const handleType = isHandle ?
    (e.target.classList.contains('tl') ? 'tl' :
     e.target.classList.contains('tr') ? 'tr' :
     e.target.classList.contains('bl') ? 'bl' : 'br') : null;

  dragState = {
    type: handleType || 'move',
    startX: e.clientX,
    startY: e.clientY,
    startBox: { ...boxNorm },
  };
});

window.addEventListener('mousemove', (e) => {
  if (!dragState) return;

  const rect = container.getBoundingClientRect();
  const dx = (e.clientX - dragState.startX) / rect.width;
  const dy = (e.clientY - dragState.startY) / rect.height;
  const s = dragState.startBox;

  if (dragState.type === 'move') {
    boxNorm.x = Math.max(0, Math.min(1 - s.w, s.x + dx));
    boxNorm.y = Math.max(0, Math.min(1 - s.h, s.y + dy));
  } else if (dragState.type === 'br') {
    boxNorm.w = Math.max(0.02, Math.min(1 - s.x, s.w + dx));
    boxNorm.h = Math.max(0.02, Math.min(1 - s.y, s.h + dy));
  } else if (dragState.type === 'bl') {
    const newW = Math.max(0.02, s.w - dx);
    boxNorm.x = s.x + s.w - newW;
    boxNorm.w = newW;
    boxNorm.h = Math.max(0.02, Math.min(1 - s.y, s.h + dy));
  } else if (dragState.type === 'tr') {
    boxNorm.w = Math.max(0.02, Math.min(1 - s.x, s.w + dx));
    const newH = Math.max(0.02, s.h - dy);
    boxNorm.y = s.y + s.h - newH;
    boxNorm.h = newH;
  } else if (dragState.type === 'tl') {
    const newW = Math.max(0.02, s.w - dx);
    boxNorm.x = s.x + s.w - newW;
    boxNorm.w = newW;
    const newH = Math.max(0.02, s.h - dy);
    boxNorm.y = s.y + s.h - newH;
    boxNorm.h = newH;
  }

  updateBoxPosition();
});

window.addEventListener('mouseup', () => { dragState = null; });

// Animation loop
function draw() {
  animationId = requestAnimationFrame(draw);

  const w = canvas.width;
  const h = canvas.height;
  ctx.fillStyle = '#111';
  ctx.fillRect(0, 0, w, h);

  if (!analyser || !isPlaying) return;

  const bufferLength = analyser.frequencyBinCount;
  const dataArray = new Uint8Array(bufferLength);
  analyser.getByteFrequencyData(dataArray);

  const sampleRate = audioBuffer?.sampleRate || 44100;
  const maxFreq = sampleRate / 2;
  const minLog = Math.log10(20);
  const maxLog = Math.log10(maxFreq);
  const logRange = maxLog - minLog;

  // Draw spectrum (log scale X)
  ctx.beginPath();
  ctx.moveTo(0, h);

  const numPoints = 200;
  for (let i = 0; i < numPoints; i++) {
    const xNorm = i / (numPoints - 1);
    const freq = Math.pow(10, minLog + xNorm * logRange);
    const bin = Math.floor(freq / maxFreq * bufferLength);
    const value = (dataArray[Math.min(bin, bufferLength - 1)] || 0) / 255;

    const x = xNorm * w;
    const y = h - value * h;
    ctx.lineTo(x, y);
  }

  ctx.lineTo(w, h);
  ctx.closePath();
  ctx.fillStyle = 'rgba(100, 80, 255, 0.5)';
  ctx.fill();
  ctx.strokeStyle = 'rgb(100, 80, 255)';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Calculate fill percentage
  const cfg = getConfig();
  const startBin = Math.floor(cfg.minHz / maxFreq * bufferLength);
  const endBin = Math.floor(cfg.maxHz / maxFreq * bufferLength);

  let peak = 0;
  for (let i = startBin; i <= endBin && i < bufferLength; i++) {
    const v = dataArray[i] / 255;
    if (v > peak) peak = v;
  }

  // Fill percentage
  let fill = 0;
  if (peak > cfg.floor) {
    fill = Math.min(1, (peak - cfg.floor) / (cfg.ceiling - cfg.floor));
  }

  // Update fill bar inside range box
  fillBar.style.height = (fill * 100) + '%';

  // Update meters
  fillMeter.style.width = (fill * 100) + '%';
  fillValue.textContent = Math.round(fill * 100) + '%';
  peakMeter.style.width = (peak * 100) + '%';
  peakValue.textContent = Math.round(peak * 100) + '%';
  fillDisplay.textContent = Math.round(fill * 100) + '%';
}

draw();
updateConfig();
</script>
</body>
</html>
